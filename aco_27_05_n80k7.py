# -*- coding: utf-8 -*-
"""ACO 27/05 n80k7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gIG5slDQePlJRhFKU6tZ-uB2Yini8kmB
"""

!pip install pandas numpy matplotlib openpyxl

import pandas as pd

# Lire les demandes des clients (en supposant que la première colonne est la date)
demandes_df = pd.read_excel("/content/demandes clients merg 80.xlsx", index_col="date")

# Lire les coordonnées (en supposant que la colonne "client" contient "entrepot", "CL1", etc.)
coordonnees_df= pd.read_excel("/content/les coordonnées des 80 clients et l'entrepot.xlsx", sheet_name="Feuil1",index_col="client ")
print(coordonnees_df.columns.tolist())

demandes_df

coordonnees_df

coordonnees_df=coordonnees_df[["Latitude", "Longitude", "X", "Y"]]

coordonnees_df

# Sélectionner une date spécifique (ex: la première date)
date_cible = demandes_df.index[0]
demandes = demandes_df.loc[date_cible].to_dict()  # Format: {"CL1": 469.78, ...}

# Extraire les coordonnées de l'entrepôt et des clients
entrepot = coordonnees_df.loc["entrepot"][["Latitude", "Longitude"]].values
clients = coordonnees_df.drop("entrepot")[["Latitude", "Longitude"]]

clients

entrepot

demandes

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.scatter(clients["Longitude"], clients["Latitude"], label="Clients", color="blue")
plt.scatter(entrepot[1], entrepot[0], label="Entrepôt", color="red", marker="s", s=100)
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.title("Répartition Géographique des Clients")
plt.legend()
plt.show()

"""Calcul de la Matrice de Distance Distance Euclidienne (si X/Y sont en mètres) :"""

from scipy.spatial import distance_matrix

coordonnees = coordonnees_df[["X", "Y"]].values  # Utiliser X/Y si disponibles
dist_matrix = distance_matrix(coordonnees, coordonnees)
dist_matrix

!pip install optuna



!pip install folium --upgrade

time_windows_df = pd.read_excel("fenetres_temps 80.xlsx", index_col="Client")

time_windows = {}
for client, row in time_windows_df.iterrows():
    # If client already exists, append to the list
    if client in time_windows:
        time_windows[client].append((row['Debut'], row['Fin']))
    # If client is new, create a new list
    else:
        time_windows[client] = [(row['Debut'], row['Fin'])]

# Load service_times (unchanged)
service_times_df = pd.read_excel("temps_service 80.xlsx", index_col="Client")
service_times = service_times_df['Temps_Service'].to_dict()
time_windows_df['Debut (heure)'] = time_windows_df['Debut'].apply(lambda x: f"{x // 60:02.0f}.{x % 60:02.0f}")
time_windows_df['Fin(heure)'] = time_windows_df['Fin'].apply(lambda x: f"{x // 60:02.0f}.{x % 60:02.0f}")

time_windows_df

service_times_df

import optuna
import folium
from folium.plugins import AntPath
import pandas as pd
import numpy as np
import random
from scipy.spatial import distance_matrix
import matplotlib.pyplot as plt

# Initialise les données et paramètres essentiels pour l'algorithme.
class ACOVRP:
    def __init__(self, dist_matrix, demandes, params, time_windows, service_times):
        self.dist_matrix = dist_matrix
        self.demandes = demandes
        self.params = params
        self.n_clients = len(demandes) - 1
        self.pheromones = np.ones_like(dist_matrix) * 0.1
        # Liste des capacités des 6 véhicules
        self.capacites_vehicules = params["capacites_vehicules"]
        # Nombre de véhicules
        self.n_vehicules = len(self.capacites_vehicules)
        # Ajouter time_windows et service_times
        self.time_windows = time_windows
        self.service_times = service_times
    #Calculer le temps de trajet entre deux points en tenant compte des contraintes temporelles.
    def temps_de_trajet(self, depart, arrivee):
            # Assurez-vous que les index sont numériques si nécessaire
            depart_index = self.get_node_index(depart)
            arrivee_index = self.get_node_index(arrivee)

            # Calculer le temps de trajet basé sur la distance (exemple)
            distance = self.dist_matrix[depart_index][arrivee_index]
            vitesse_moyenne = 50  # km/h
            temps = distance / vitesse_moyenne
            return temps
    #Convertir les identifiants de nœuds en indices numériques cohérents.
    def get_node_index(self, node):
        if node == 'entrepot':
            return 0
        elif isinstance(node, str) and node.startswith('CL'):
            return int(node[2:])  # Extraire le numéro du client
        else:
            return node  # Si node est déjà un index numérique
    # Exécute l'algorithme pour un nombre fixé d'itérations et retourne la meilleure solution trouvée.
    def run(self):
                meilleure_distance = float('inf')
                meilleure_solution = None

                for _ in range(self.params["iterations"]):
                    solutions = self.generer_solutions()
                    self.mettre_a_jour_pheromones(solutions)

                    for solution in solutions:
                        # Vérifier que tous les clients sont servis
                        clients_servis = set()
                        for route, _, distance in solution:
                            clients_servis.update(route[1:-1])

                        if len(clients_servis) == self.n_clients:
                            total_distance = sum(d for _, _, d in solution)
                            if total_distance < meilleure_distance:
                                meilleure_distance = total_distance
                                meilleure_solution = solution

                # Si aucune solution valide n'a été trouvée, utiliser une solution de secours
                if meilleure_solution is None:
                    meilleure_solution = self.generer_solution_garantie()

                    meilleure_distance = sum(d for _, _, d in meilleure_solution)
                return meilleure_solution, meilleure_distance

    # Génère une solution qui garantit la livraison de tous les clients
    def generer_solution_garantie(self):
        # Trier les clients par demande décroissante
        clients = list(range(1, self.n_clients + 1))
        clients.sort(key=lambda c: self.demandes[c], reverse=True)

        # Trier les véhicules par capacité décroissante
        vehicules = list(range(self.n_vehicules))
        vehicules.sort(key=lambda v: self.capacites_vehicules[v], reverse=True)

        solution = []
        clients_restants = clients.copy()

        # Assigner les clients aux véhicules en utilisant une approche gloutonne
        for v_idx in vehicules:
            if not clients_restants:
                break

            capacite = self.capacites_vehicules[v_idx]
            route = [0]  # Départ de l'entrepôt
            charge_actuelle = 0

            # Essayer d'ajouter autant de clients que possible à ce véhicule
            i = 0
            while i < len(clients_restants):
                client = clients_restants[i]
                if charge_actuelle + self.demandes[client] <= capacite:
                    route.append(client)
                    charge_actuelle += self.demandes[client]
                    clients_restants.pop(i)
                else:
                    i += 1

            # Ajouter le retour à l'entrepôt
            route.append(0)

            # Calculer la distance de cette route
            distance = 0
            for i in range(len(route) - 1):
                distance += self.dist_matrix[route[i]][route[i+1]]

            # Ajouter la route à la solution
            solution.append((route, v_idx, distance))

        # S'il reste des clients à servir et qu'on a utilisé tous les véhicules
        if clients_restants:
            # Répartir les clients restants aux véhicules existants
            for client in clients_restants:
                # Trouver le véhicule avec le plus d'espace disponible
                best_v_idx = -1
                best_capacite_restante = -1

                for i, (route, v_idx, _) in enumerate(solution):
                    capacite = self.capacites_vehicules[v_idx]
                    charge_actuelle = sum(self.demandes[client] for client in route[1:-1])
                    capacite_restante = capacite - charge_actuelle

                    if capacite_restante >= self.demandes[client] and capacite_restante > best_capacite_restante:
                        best_capacite_restante = capacite_restante
                        best_v_idx = i

                if best_v_idx != -1:
                    # Ajouter le client à la meilleure position dans la route
                    route, v_idx, _ = solution[best_v_idx]
                    route_temp = route[:-1]  # Sans le retour à l'entrepôt

                    meilleure_pos = 0
                    meilleur_cout = float('inf')

                    for pos in range(1, len(route_temp) + 1):
                        if pos == 1:
                            cout_insertion = (self.dist_matrix[0][client] +
                                             self.dist_matrix[client][route_temp[1]] -
                                             self.dist_matrix[0][route_temp[1]])
                        elif pos == len(route_temp):
                            cout_insertion = (self.dist_matrix[route_temp[-1]][client] +
                                             self.dist_matrix[client][0] -
                                             self.dist_matrix[route_temp[-1]][0])
                        else:
                            cout_insertion = (self.dist_matrix[route_temp[pos-1]][client] +
                                             self.dist_matrix[client][route_temp[pos]] -
                                             self.dist_matrix[route_temp[pos-1]][route_temp[pos]])

                        if cout_insertion < meilleur_cout:
                            meilleur_cout = cout_insertion
                            meilleure_pos = pos

                    # Insérer le client à la meilleure position
                    nouvelle_route = route_temp[:meilleure_pos] + [client] + route_temp[meilleure_pos:]
                    nouvelle_route.append(0)  # Ajouter le retour à l'entrepôt

                    # Calculer la nouvelle distance
                    nouvelle_distance = 0
                    for j in range(len(nouvelle_route) - 1):
                        nouvelle_distance += self.dist_matrix[nouvelle_route[j]][nouvelle_route[j+1]]

                    # Mettre à jour la solution
                    solution[best_v_idx] = (nouvelle_route, v_idx, nouvelle_distance)

            # S'il reste encore des clients, augmenter temporairement les capacités des véhicules
            clients_restants = [c for c in clients if not any(c in route[1:-1] for route, _, _ in solution)]
            if clients_restants:
                print(f"Avertissement: La capacité des véhicules a été temporairement augmentée pour servir tous les clients")
                for client in clients_restants:
                    # Trouver le véhicule avec la charge la plus légère
                    best_v_idx = min(range(len(solution)), key=lambda i: sum(self.demandes[c] for c in solution[i][0][1:-1]))

                    route, v_idx, _ = solution[best_v_idx]
                    # Trouver la meilleure position pour insertion
                    route_temp = route[:-1]
                    meilleure_pos = 0
                    meilleur_cout = float('inf')

                    for pos in range(1, len(route_temp) + 1):
                        if pos == 1:
                            cout_insertion = (self.dist_matrix[0][client] +
                                             self.dist_matrix[client][route_temp[1]] -
                                             self.dist_matrix[0][route_temp[1]])
                        elif pos == len(route_temp):
                            cout_insertion = (self.dist_matrix[route_temp[-1]][client] +
                                             self.dist_matrix[client][0] -
                                             self.dist_matrix[route_temp[-1]][0])
                        else:
                            cout_insertion = (self.dist_matrix[route_temp[pos-1]][client] +
                                             self.dist_matrix[client][route_temp[pos]] -
                                             self.dist_matrix[route_temp[pos-1]][route_temp[pos]])

                        if cout_insertion < meilleur_cout:
                            meilleur_cout = cout_insertion
                            meilleure_pos = pos

                    # Insérer le client à la meilleure position
                    nouvelle_route = route_temp[:meilleure_pos] + [client] + route_temp[meilleure_pos:]
                    nouvelle_route.append(0)

                    # Calculer la nouvelle distance
                    nouvelle_distance = 0
                    for j in range(len(nouvelle_route) - 1):
                        nouvelle_distance += self.dist_matrix[nouvelle_route[j]][nouvelle_route[j+1]]

                    # Mettre à jour la solution
                    solution[best_v_idx] = (nouvelle_route, v_idx, nouvelle_distance)

        return solution

    # Génère des solutions complètes pour chaque fourmi en utilisant les véhicules
    def generer_solutions(self):
        solutions = []
        for _ in range(self.params["n_fourmis"]):
            solution = []
            clients_restants = list(range(1, self.n_clients + 1))
            # Copier les véhicules disponibles
            vehicules_disponibles = list(range(self.n_vehicules))

            # Tant qu'il reste des clients à visiter et des véhicules disponibles
            while clients_restants and vehicules_disponibles:
                # Choisir un véhicule
                vehicule_idx = random.choice(vehicules_disponibles)
                capacite = self.capacites_vehicules[vehicule_idx]

                # Générer une sous-route pour ce véhicule
                # Dans la fonction generer_solutions :
                route, charge, distance, _ = self.generer_sous_route(clients_restants, capacite)
                # Ceci ignore la valeur de temps supplémentaire renvoyée par generer_sous_route

                # Si la route est utile (visite au moins un client)
                if len(route) > 2:  # Plus que juste entrepôt-entrepôt
                    solution.append((route, vehicule_idx, distance))
                    vehicules_disponibles.remove(vehicule_idx)
                else:
                    # Même si la route ne visite aucun client, on utilise quand même le véhicule
                    # pour éviter de le réutiliser
                    vehicules_disponibles.remove(vehicule_idx)

            # S'il reste des clients à visiter, essayer de les assigner aux véhicules existants
            if clients_restants and solution:
                clients_non_assignes = self.assigner_clients_restants(clients_restants, solution)

                # S'il reste encore des clients non assignés, noter le problème
                if clients_non_assignes:
                    # Pour assurer que tous les clients sont servis, ajouter les clients restants
                    # au véhicule le moins chargé, même si cela dépasse sa capacité
                    clients_restants = clients_non_assignes

            solutions.append(solution)
        return solutions

    # Assigne les clients restants aux véhicules déjà en route
    def assigner_clients_restants(self, clients_restants, solution):
        # Trier les véhicules par capacité disponible (décroissante)
        vehicules_avec_espace = []
        for i, (route, vehicule_idx, _) in enumerate(solution):
            capacite = self.capacites_vehicules[vehicule_idx]
            charge_actuelle = sum(self.demandes[client] for client in route[1:-1])
            capacite_restante = capacite - charge_actuelle
            vehicules_avec_espace.append((i, capacite_restante))

        vehicules_avec_espace.sort(key=lambda x: x[1], reverse=True)

        clients_non_assignes = []
        for client in clients_restants:
            assigne = False
            for i, capacite_restante in vehicules_avec_espace:
                if capacite_restante >= self.demandes[client]:
                    route, vehicule_idx, distance = solution[i]
                    # Insérer le client au meilleur endroit de la route
                    route_temp = route[:-1]  # Sans le retour à l'entrepôt
                    meilleure_pos = 0
                    meilleur_cout = float('inf')

                    for pos in range(1, len(route_temp) + 1):
                        if pos == 1:
                            cout_insertion = (self.dist_matrix[0][client] +
                                             self.dist_matrix[client][route_temp[1]] -
                                             self.dist_matrix[0][route_temp[1]])
                        elif pos == len(route_temp):
                            cout_insertion = (self.dist_matrix[route_temp[-1]][client] +
                                             self.dist_matrix[client][0] -
                                             self.dist_matrix[route_temp[-1]][0])
                        else:
                            cout_insertion = (self.dist_matrix[route_temp[pos-1]][client] +
                                             self.dist_matrix[client][route_temp[pos]] -
                                             self.dist_matrix[route_temp[pos-1]][route_temp[pos]])

                        if cout_insertion < meilleur_cout:
                            meilleur_cout = cout_insertion
                            meilleure_pos = pos

                    # Insérer le client à la meilleure position
                    nouvelle_route = route_temp[:meilleure_pos] + [client] + route_temp[meilleure_pos:]
                    nouvelle_route.append(0)  # Ajouter le retour à l'entrepôt

                    # Calculer la nouvelle distance
                    nouvelle_distance = 0
                    for j in range(len(nouvelle_route) - 1):
                        nouvelle_distance += self.dist_matrix[nouvelle_route[j]][nouvelle_route[j+1]]

                    # Mettre à jour la solution
                    solution[i] = (nouvelle_route, vehicule_idx, nouvelle_distance)

                    # Mettre à jour la capacité restante du véhicule
                    vehicules_avec_espace[vehicules_avec_espace.index((i, capacite_restante))] = (i, capacite_restante - self.demandes[client])
                    vehicules_avec_espace.sort(key=lambda x: x[1], reverse=True)

                    assigne = True
                    break

            if not assigne:
                clients_non_assignes.append(client)

        return clients_non_assignes

    def generer_sous_route(self, clients_restants, capacite_vehicule):
            route = [0]  # Commence à l'entrepôt
            charge_actuelle = 0
            distance_totale = 0
            temps_total = 0

            while clients_restants:
                current_node = route[-1]

                clients_possibles = [
                    client for client in clients_restants
                    if (charge_actuelle + self.demandes[client]) <= capacite_vehicule
                ]

                # Filtrer les clients possibles en fonction des fenêtres temporelles
                clients_possibles_temps = []
                for client in clients_possibles:
                    temps_arrivee = temps_total + self.temps_de_trajet(current_node, client)
                    debut_fenetre, fin_fenetre = self.time_windows.get(client, [(0, float('inf'))])[0]

                    if debut_fenetre <= temps_arrivee + self.service_times.get(client, 0) <= fin_fenetre:
                        clients_possibles_temps.append(client)

                if not clients_possibles_temps:  # Si aucun client possible ne respecte la fenêtre temporelle, sortir de la boucle
                    break

                # Choisir le prochain client parmi ceux qui respectent les contraintes de temps
                prochain_client = self.choisir_prochain_client(current_node, clients_possibles_temps, temps_total)

                if prochain_client is None:  # Si aucun client n'a pu être choisi, sortir de la boucle
                    break

                route.append(prochain_client)
                charge_actuelle += self.demandes[prochain_client]
                distance_totale += self.dist_matrix[current_node][prochain_client]  # ou self.dist_matrix[self.get_node_index(current_node)][self.get_node_index(prochain_client)] si vous utilisez get_node_index
                temps_total += self.temps_de_trajet(current_node, prochain_client) + self.service_times.get(prochain_client, 0)
                clients_restants.remove(prochain_client)

            distance_totale += self.dist_matrix[route[-1]][0]  # Retour à l'entrepôt
            temps_total += self.temps_de_trajet(route[-1], 0)
            route.append(0)  # Terminer la route à l'entrepôt

            return route, charge_actuelle, distance_totale, temps_total

    # Implémente la règle de décision probabiliste des fourmis basée sur les phéromones et l'heuristique.
    def choisir_prochain_client(self, current_node, clients_possibles, temps_actuel): # Ajouter temps_actuel comme argument
        poids = []
        total = 0.0

        for cl in clients_possibles:
            # Vérifier la fenêtre temporelle
            temps_arrivee = temps_actuel + self.temps_de_trajet(current_node, cl)
            debut_fenetre, fin_fenetre = self.time_windows.get(cl, [(0, float('inf'))])[0]

            if debut_fenetre <= temps_arrivee <= fin_fenetre:  # Si la fenêtre temporelle est respectée
                pheromone = self.pheromones[current_node][cl] ** self.params["alpha"]
                heuristic = (1.0 / self.dist_matrix[current_node][cl]) ** self.params["beta"]
                poids.append(pheromone * heuristic)
                total += pheromone * heuristic
            else:
                # Ignorer le client si la fenêtre temporelle est violée
                pass

        if total == 0:
            # Si aucun client possible ne respecte la fenêtre temporelle, choisir au hasard
            return random.choice(clients_possibles) if clients_possibles else None

        probas = [p / total for p in poids]
        return random.choices(clients_possibles, weights=probas, k=1)[0] if probas else None

    # Met à jour les phéromones selon le principe d'évaporation et de renforcement des bonnes routes.
    def mettre_a_jour_pheromones(self, solutions):
        # Évaporation
        self.pheromones *= (1 - self.params["evaporation"])

        # Dépôt pour chaque solution
        for solution in solutions:
            # Vérifier que tous les clients sont servis
            clients_servis = set()
            for route, _, _ in solution:
                clients_servis.update(route[1:-1])

            # Si tous les clients sont servis, donner plus d'importance à cette solution
            multiplicateur = 3.0 if len(clients_servis) == self.n_clients else 1.0

            for route, _, distance in solution:
                if distance == 0:
                    continue
                delta = (1 / distance) * multiplicateur
                for i in range(len(route)-1):
                    self.pheromones[route[i]][route[i+1]] += delta
def objective(trial):
    # Hyperparamètres à optimiser
    params = {
        "n_vehicules": trial.suggest_int("n_vehicules", 1, 7),
        "n_fourmis": trial.suggest_int("n_fourmis", 10, 80),
        "alpha": trial.suggest_float("alpha", 0.5, 2),
        "beta": trial.suggest_float("beta", 1, 5),
        "evaporation": trial.suggest_float("evaporation", 0.1, 0.6),
        "iterations": trial.suggest_int("iterations", 50, 200),
    }

    # Calculate minimum and maximum capacity based on total demand
    demande_totale_par_vehicule = demande_totale / params["n_vehicules"]
    min_capacite = int(demande_totale_par_vehicule * 0.8)  # Minimum 80% of average demand
    max_capacite = int(demande_totale_par_vehicule * 1.5)  # Maximum 150% of average demand

    params["capacites_vehicules"] = [
        trial.suggest_int(f"capacite_v{i+1}", min_capacite, max_capacite)
        for i in range(params["n_vehicules"])
    ]

    # Données des véhicules (type et émissions)
    vehicules_data = {
            0: {"type": "essence", "emissions": 150,"age": 5},
            1: {"type": "diesel", "emissions": 180,"age": 2},
            2: {"type": "electrique", "emissions": 90,"age": 1},
            3: {"type": "hybride", "emissions": 130,"age": 8},
            4: {"type": "diesel", "emissions": 170,"age": 4},
            5: {"type": "essence", "emissions": 160,"age":3 },
            6: {"type": "essence", "emissions": 155,"age": 2},  # Added vehicle 7
        }

    # Configuration fixe pour l'optimisation
    aco = ACOVRP(dist_matrix, demandes, params, time_windows, service_times)
    aco.time_windows = time_windows
    aco.service_times = service_times
    solution, distance = aco.run()

    # Vérifier si tous les clients sont servis
    clients_servis = set()
    for route, _, _ in solution:
        clients_servis.update(route[1:-1])

    # Pénalité si tous les clients ne sont pas servis
    clients_non_servis = set(range(1, aco.n_clients + 1)) - clients_servis
    penalite = len(clients_non_servis) * 10000  # Forte pénalité

    # Pénalité pour les violations de la fenêtre temporelle
    penalite_temps = 0
    for route, vehicule_idx, _ in solution:
        temps_actuel = 0
        for i in range(len(route) - 1):
            client_actuel = route[i]
            client_suivant = route[i + 1]
            temps_actuel += aco.temps_de_trajet(client_actuel, client_suivant)

            if client_suivant != 0:  # Si ce n'est pas l'entrepôt
                temps_actuel += aco.service_times.get(client_suivant, 0)  # Temps de service
                fenetre_temps = aco.time_windows.get(client_suivant, [(0, float('inf'))])[0]  # Fenêtre temporelle

                if temps_actuel < fenetre_temps[0]:  # Arrivée trop tôt
                    penalite_temps += fenetre_temps[0] - temps_actuel
                elif temps_actuel > fenetre_temps[1]:  # Arrivée trop tard
                    penalite_temps += temps_actuel - fenetre_temps[1]

    # Calcul des émissions de CO2
    total_emissions = 0
    for route, vehicule_idx, distance in solution:
        emissions_vehicule = vehicules_data[vehicule_idx]["emissions"]
        total_emissions += emissions_vehicule * distance
    # Ajouter une pénalité pour le nombre de véhicules
        # Ajouter une pénalité pour le nombre de véhicules
    penalite_vehicules = len(solution) * 50  # Use params["n_vehicules"] instead of n_vehicules

# Calcul de la pénalité liée à l'ancienneté des véhicules
    penalite_anciennete = 0
    for route, vehicule_idx, distance in solution:
        age_vehicule = vehicules_data[vehicule_idx]["age"]
        penalite_anciennete += age_vehicule * distance * 0.1 # Exemple de calcul de pénalité




    # Retourner la valeur objectif combinée
    return  (distance
            + penalite
            + penalite_temps * 100
            + total_emissions * 0.1
            + penalite_vehicules
            + penalite_anciennete )



def visualiser_route(solution, coordonnees_df):
    plt.figure(figsize=(12, 10))

    # Couleurs pour différencier les véhicules
    couleurs = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'black']

    # Coordonnées de l'entrepôt
    entrepot_x = coordonnees_df.loc["entrepot", "X"]
    entrepot_y = coordonnees_df.loc["entrepot", "Y"]
    plt.scatter(entrepot_x, entrepot_y, c='black', s=200, marker='*', label='Entrepôt')

    # Coordonnées des clients
    clients = [f"CL{i}" for i in range(1, 81)]
    x_clients = coordonnees_df.loc[clients, "X"].values
    y_clients = coordonnees_df.loc[clients, "Y"].values
    plt.scatter(x_clients, y_clients, c='gray', s=50, label='Clients')

    # Tracer les routes pour chaque véhicule
    for i, (route, vehicule_idx, distance) in enumerate(solution):
        couleur = couleurs[vehicule_idx % len(couleurs)]
        label = f"Véhicule {vehicule_idx+1} - {distance:.2f}km"

        # Tracer la route
        for j in range(len(route)-1):
            if route[j] == 0:
                x1, y1 = entrepot_x, entrepot_y
            else:
                x1, y1 = coordonnees_df.loc[f"CL{route[j]}", "X"], coordonnees_df.loc[f"CL{route[j]}", "Y"]

            if route[j+1] == 0:
                x2, y2 = entrepot_x, entrepot_y
            else:
                x2, y2 = coordonnees_df.loc[f"CL{route[j+1]}", "X"], coordonnees_df.loc[f"CL{route[j+1]}", "Y"]

            plt.plot([x1, x2], [y1, y2], c=couleur, alpha=0.7)

            # Pour le premier segment uniquement, ajouter l'étiquette au graphique
            if j == 0:
                plt.plot([x1, x2], [y1, y2], c=couleur, alpha=0.7, label=label)

    plt.title("Routes optimisées avec 6 véhicules de capacités différentes")
    plt.legend(loc='best')
    plt.grid(True)
    plt.show()
import folium

import folium
from folium.plugins import AntPath

import folium
import requests
from folium.plugins import AntPath

def get_route(start_coords, end_coords):
    """
    Récupère le trajet réel entre deux points via OSRM
    """
    url = f"http://router.project-osrm.org/route/v1/driving/{start_coords[1]},{start_coords[0]};{end_coords[1]},{end_coords[0]}?overview=full&geometries=geojson"
    response = requests.get(url)
    data = response.json()

    if data['code'] == 'Ok':
        return [(coord[1], coord[0]) for coord in data['routes'][0]['geometry']['coordinates']]
    return [start_coords, end_coords]  # Fallback si échec

def visualiser_route_reelle(solution, coordonnees_df):
    entrepot_lat = coordonnees_df.loc["entrepot", "Latitude"]
    entrepot_lon = coordonnees_df.loc["entrepot", "Longitude"]

    carte = folium.Map(location=[entrepot_lat, entrepot_lon],
                      zoom_start=13,
                      tiles='https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
                      attr='OSM France')

    # Entrepôt
    folium.Marker(
        [entrepot_lat, entrepot_lon],
        icon=folium.Icon(icon='warehouse', prefix='fa', color='black'),
        tooltip="Entrepôt"
    ).add_to(carte)

    # Clients
    for idx, row in coordonnees_df.iterrows():
        if idx.startswith("CL"):
            folium.CircleMarker(
                location=[row['Latitude'], row['Longitude']],
                radius=5,
                color='#404040',
                fill=True,
                fill_color='#FFFFFF',
                tooltip=idx
            ).add_to(carte)
    couleurs_vehicules = ['#FF0000', '#0000FF', '#00FF00', '#FFA500', '#800080', '#A52A2A', '#000000']

    for route, vehicule_idx, distance in solution:
        coords = []

        # Génération des segments de route réalistes
        for i in range(len(route)-1):
            start = route[i]
            end = route[i+1]

            # Coordonnées de départ
            if start == 0:
                start_lat, start_lon = entrepot_lat, entrepot_lon
            else:
                client_start = f"CL{start}"
                start_lat = coordonnees_df.loc[client_start, "Latitude"]
                start_lon = coordonnees_df.loc[client_start, "Longitude"]

            # Coordonnées d'arrivée
            if end == 0:
                end_lat, end_lon = entrepot_lat, entrepot_lon
            else:
                client_end = f"CL{end}"
                end_lat = coordonnees_df.loc[client_end, "Latitude"]
                end_lon = coordonnees_df.loc[client_end, "Longitude"]

            # Récupération du trajet réel
            segment = get_route((start_lat, start_lon), (end_lat, end_lon))
            coords.extend(segment)

        # Tracé de la route
        folium.PolyLine(
            coords,
            color=couleurs_vehicules[vehicule_idx],
            weight=3,
            opacity=0.8,
            line_cap='round',
            tooltip=f"Véhicule {vehicule_idx+1} | {distance:.1f} km"
        ).add_to(carte)

        # Animation du trajet
        AntPath(
            coords,
            color=couleurs_vehicules[vehicule_idx],
            delay=1500,
            dashArray=[10, 15],
            weight=2
        ).add_to(carte)

    return carte
# Chargement des données
demandes_df = pd.read_excel("/content/demandes clients merg 80.xlsx", index_col="date")
coordonnees_df = pd.read_excel("/content/les coordonnées des 80 clients et l'entrepot.xlsx", index_col="client ")

# Préparation des données
clients_ordered = [f"CL{i}" for i in range(1, 81)]
coords = coordonnees_df.loc[["entrepot"] + clients_ordered][["X", "Y"]].values
dist_matrix = distance_matrix(coords, coords)
date_cible = demandes_df.index[0]
demandes = [0] + [demandes_df.loc[date_cible, f"CL{i}"] for i in range(1, 81)]

# Calculer la demande totale pour dimensionner les véhicules
demande_totale = sum(demandes[1:])
print(f"Demande totale à satisfaire: {demande_totale}")

# Configuration de l'étude Optuna
study = optuna.create_study(
    direction="minimize",
    sampler=optuna.samplers.TPESampler(),
    pruner=optuna.pruners.MedianPruner()
)

# Exécution de l'optimisation avec plus d'itérations pour trouver une solution valide
study.optimize(objective, n_trials=50, show_progress_bar=True)

# Résultats de l'optimisation
print("\nMeilleurs paramètres trouvés:")
best_params = study.best_params
print(best_params)

# Validation finale avec plus d'itérations
final_params = best_params.copy()
nombre_vehicules_optimal = best_params["n_vehicules"]
capacites_optimales = [best_params[f"capacite_v{i+1}"] for i in range(nombre_vehicules_optimal)]
final_params["iterations"] = 300  # Augmentation pour convergence finale



# Utiliser les capacités manuelles ou optimisées
final_params["capacites_vehicules"] =[best_params[f"capacite_v{i+1}"] for i in range(nombre_vehicules_optimal)]  # ou best_params["capacites_vehicules"]

aco = ACOVRP(dist_matrix, demandes, final_params, time_windows, service_times) # Inclure time_windows et service_times
meilleure_solution, distance_totale = aco.run()
vehicules_data = {
            0: {"type": "essence", "emissions": 150,"age": 5},
            1: {"type": "diesel", "emissions": 180,"age": 2},
            2: {"type": "electrique", "emissions": 90,"age": 1},
            3: {"type": "hybride", "emissions": 130,"age": 8},
            4: {"type": "diesel", "emissions": 170,"age": 4},
            5: {"type": "essence", "emissions": 160,"age":3 },
            6: {"type": "essence", "emissions": 155,"age": 2},  # Added vehicle 7
        }
# Calculate emissions per vehicle
emissions_par_vehicule = {i: 0 for i in range(aco.n_vehicules)}  # Initialize emissions for each vehicle
total_emissions = 0

for route, vehicule_idx, distance in meilleure_solution:
    emissions_vehicule = vehicules_data[vehicule_idx]["emissions"]
    emissions_par_vehicule[vehicule_idx] += emissions_vehicule * distance  # Accumulate emissions for this vehicle
    total_emissions += emissions_vehicule * distance

# Afficher les émissions totales de CO2
print(f"Émissions totales de CO2: {total_emissions:.2f} g")
# Vérifier si tous les clients sont servis
clients_servis = set()
for route, _, _ in meilleure_solution:
    clients_servis.update(route[1:-1])

clients_non_servis = set(range(1, aco.n_clients + 1)) - clients_servis
if clients_non_servis:
    print(f"\nAttention: {len(clients_non_servis)} clients non servis: {clients_non_servis}")
    print("Génération d'une solution garantie pour servir tous les clients...")
    meilleure_solution = aco.generer_solution_garantie()
    distance_totale = sum(d for _, _, d in meilleure_solution)

    # Vérification après solution garantie
    clients_servis = set()
    for route, _, _ in meilleure_solution:
        clients_servis.update(route[1:-1])
    clients_non_servis = set(range(1, aco.n_clients + 1)) - clients_servis

    if clients_non_servis:
        print(f"\nAttention: {len(clients_non_servis)} clients non servis: {clients_non_servis}")
        choix = input("Voulez-vous faire un autre itinéraire (o/n) ou les programmer pour le lendemain (d) ? ")

        if choix.lower() == 'o':
            # Placeholder pour relance de l'optimisation
            print("Relance de l'optimisation avec paramètres ajustés...")
            # Ajouter ici la logique de réoptimisation

        elif choix.lower() == 'd':  # Correction d'indentation
            print("Les clients suivants seront programmés pour le lendemain :")
            print(clients_non_servis)
            # Ajouter ici la logique de report de livraison

        else:
            print("Choix non valide. Les clients non servis ne seront pas traités.")
    else:
        print("\nTous les clients sont servis!")

print(f"\nDistance finale après optimisation: {distance_totale:.2f} km")

# Détails des routes
print("\nDétails des routes:")
for i, (route, vehicule_idx, distance) in enumerate(meilleure_solution):
    charge = sum(demandes[client] for client in route[1:-1])
    capacite = aco.capacites_vehicules[vehicule_idx]
    clients = [f"CL{c}" for c in route[1:-1]]
    emissions = emissions_par_vehicule[vehicule_idx]  # Get emissions for this vehicle

    print(f"Véhicule {vehicule_idx+1} (capacité: {capacite}): {clients}")
    print(f"  - Charge: {charge} ({charge/capacite*100:.1f}% de la capacité)")
    print(f"  - Distance: {distance:.2f} km")
    print(f"  - Émissions: {emissions:.2f} g")  # Print emissions for this vehicle
    print(f"  - Route: {route}")

# Visualisation
visualiser_route(meilleure_solution, coordonnees_df)
carte = visualiser_route_reelle(meilleure_solution, coordonnees_df)
carte.save('carte_routes_reelles.html')



